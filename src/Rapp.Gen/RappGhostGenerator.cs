using System;
using System.Text;
using System.Linq;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Rapp.Gen
{
    [Generator]
    public class RappGhostGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var p = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: (s, _) => IsTarget(s),
                transform: (ctx, _) => GetTarget(ctx))
                .Where(m => m != null);

            context.RegisterSourceOutput(p, Execute);
        }

        private static bool IsTarget(SyntaxNode node)
        {
            return node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0;
        }

        private static ClassDeclarationSyntax? GetTarget(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            
            foreach (var attributeList in classDeclaration.AttributeLists)
            {
                foreach (var attribute in attributeList.Attributes)
                {
                    if (context.SemanticModel.GetSymbolInfo(attribute).Symbol is IMethodSymbol attributeSymbol &&
                        attributeSymbol.ContainingType.ToDisplayString() == "Rapp.RappGhostAttribute")
                    {
                        return classDeclaration;
                    }
                }
            }
            return null;
        }

        private static void Execute(SourceProductionContext context, ClassDeclarationSyntax? classDecl)
        {
            if (classDecl is null) return;

            var className = classDecl.Identifier.Text;
            var ghostName = $"{className}Ghost";
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            
            string ns = GetNamespace(classDecl);

            sb.AppendLine("using System;");
            sb.AppendLine("using System.Buffers.Binary;");
            sb.AppendLine("using System.Runtime.InteropServices;");
            sb.AppendLine("using Rapp;"); // For RappWriter
            sb.AppendLine();
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            
            // --- GHOST STRUCT ---
            sb.AppendLine($"    public ref struct {ghostName}");
            sb.AppendLine("    {");
            sb.AppendLine("        private readonly ReadOnlySpan<byte> _buffer;");
            sb.AppendLine();
            sb.AppendLine($"        public {ghostName}(ReadOnlySpan<byte> buffer)");
            sb.AppendLine("        {");
            sb.AppendLine("            _buffer = buffer;");
            sb.AppendLine("        }");
            sb.AppendLine();

            int currentOffset = 0;
            var properties = new List<(string Name, string Type, int Offset, bool IsVar)>();

            foreach (var member in classDecl.Members)
            {
                if (member is PropertyDeclarationSyntax prop)
                {
                    string propName = prop.Identifier.Text;
                    string propType = prop.Type.ToString(); // "string", "string?", "int", etc.
                    
                    // Normalize type for lookup
                    string normalizedType = propType.TrimEnd('?');
                    
                    int size = GetSize(normalizedType);
                    bool isString = normalizedType == "string";

                    properties.Add((propName, propType, currentOffset, isString));
                    
                    // Increment offset for HEAD calculation
                    currentOffset += size;
                }
            }

            // Generate Getters
            foreach (var p in properties)
            {
                string normalizedType = p.Type.TrimEnd('?');
                string? getter = GenerateGetter(normalizedType, p.Offset);
                
                if (p.IsVar) // string or string? -> ReadOnlySpan<byte>
                {
                    // Special handling for string property in Ghost
                    sb.AppendLine($"        public ReadOnlySpan<byte> {p.Name}");
                    sb.AppendLine(getter);
                    
                    // Helper for string
                    sb.AppendLine($"        public string {p.Name}String => System.Text.Encoding.UTF8.GetString({p.Name});");
                }
                else if (getter != null)
                {
                    sb.AppendLine($"        public {normalizedType} {p.Name} => {getter};");
                }
            }

            sb.AppendLine("    }"); // End struct

            // --- WRITER EXTENSIONS ---
            sb.AppendLine();
            sb.AppendLine($"    public static class {className}RappExtensions");
            sb.AppendLine("    {");
            sb.AppendLine($"        public static int WriteTo(this {className} value, Span<byte> buffer)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var writer = new RappWriter(buffer, headSize: {currentOffset});");
            
            foreach (var p in properties)
            {
                string normalizedType = p.Type.TrimEnd('?');
                GenerateWriteCall(sb, p.Name, normalizedType);
            }

            sb.AppendLine("            return writer.Length;");
            sb.AppendLine("        }");
            sb.AppendLine();

            // --- ComputeSize ---
            sb.AppendLine($"        public static int ComputeSize(this {className} value)");
            sb.AppendLine("        {");
            sb.AppendLine($"            int size = {currentOffset}; // Head Size");
            foreach (var p in properties)
            {
                 // Normalized type is needed for logic check, though GetByteCount handles string?
                if (p.IsVar)
                {
                    sb.AppendLine($"            if (value.{p.Name} != null)");
                    sb.AppendLine($"            {{");
                    sb.AppendLine($"                size += 2 + System.Text.Encoding.UTF8.GetByteCount(value.{p.Name});");
                    sb.AppendLine($"            }}");
                }
            }
            sb.AppendLine("            return size;");
            sb.AppendLine("        }");
            sb.AppendLine();

            // --- ToBytes ---
            sb.AppendLine($"        public static byte[] ToBytes(this {className} value)");
            sb.AppendLine("        {");
            sb.AppendLine("            int size = value.ComputeSize();");
            sb.AppendLine("            byte[] buffer = new byte[size];");
            sb.AppendLine("            value.WriteTo(buffer);");
            sb.AppendLine("            return buffer;");
            sb.AppendLine("        }");

            sb.AppendLine("    }");

            sb.AppendLine("}"); // End namespace

            context.AddSource($"{ghostName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static int GetSize(string type)
        {
            return type switch
            {
                "int" => 4,
                "uint" => 4,
                "long" => 8,
                "ulong" => 8,
                "short" => 2,
                "ushort" => 2,
                "byte" => 1,
                "bool" => 1,
                "double" => 8,
                "float" => 4,
                "string" => 2, // Pointer size (ushort)
                _ => 0,
            };
        }

        private static string? GenerateGetter(string type, int offset)
        {
            if (type == "string")
            {
                return $@"
        {{
            get
            {{
                ushort ptr = BinaryPrimitives.ReadUInt16LittleEndian(_buffer.Slice({offset}));
                if (ptr == 0) return ReadOnlySpan<byte>.Empty;
                var tail = _buffer.Slice(ptr);
                ushort length = BinaryPrimitives.ReadUInt16LittleEndian(tail);
                return tail.Slice(2, length);
            }}
        }}";
            }
            // ... (rest of implementation)

            return type switch
            {
                "int" => $"BinaryPrimitives.ReadInt32LittleEndian(_buffer.Slice({offset}))",
                "uint" => $"BinaryPrimitives.ReadUInt32LittleEndian(_buffer.Slice({offset}))",
                "long" => $"BinaryPrimitives.ReadInt64LittleEndian(_buffer.Slice({offset}))",
                "ulong" => $"BinaryPrimitives.ReadUInt64LittleEndian(_buffer.Slice({offset}))",
                "short" => $"BinaryPrimitives.ReadInt16LittleEndian(_buffer.Slice({offset}))",
                "ushort" => $"BinaryPrimitives.ReadUInt16LittleEndian(_buffer.Slice({offset}))",
                "bool" => $"_buffer[{offset}] != 0",
                "byte" => $"_buffer[{offset}]",
                "double" => $"BitConverter.Int64BitsToDouble(BinaryPrimitives.ReadInt64LittleEndian(_buffer.Slice({offset})))", 
                _ => null
            };
        }

        private static void GenerateWriteCall(StringBuilder sb, string name, string type)
        {
            string call = type switch
            {
                "int" => $"writer.WriteInt32(value.{name});",
                "long" => $"writer.WriteInt64(value.{name});",
                "short" => $"writer.WriteInt16(value.{name});",
                "byte" => $"writer.WriteByte(value.{name});",
                "bool" => $"writer.WriteBool(value.{name});",
                "double" => $"writer.WriteDouble(value.{name});", 
                "float" => $"writer.WriteSingle(value.{name});",
                "string" => $"writer.WriteString(value.{name});",
                _ => $"// Unsupported type: {type}"
            };
            sb.AppendLine($"            {call}");
        }

        private static string GetNamespace(SyntaxNode node)
        {
            var curr = node.Parent;
            while (curr != null)
            {
                if (curr is NamespaceDeclarationSyntax ns) return ns.Name.ToString();
                if (curr is FileScopedNamespaceDeclarationSyntax fns) return fns.Name.ToString();
                curr = curr.Parent;
            }
            return "Rapp.Generated";
        }
    }
}
