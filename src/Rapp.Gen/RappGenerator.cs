// Copyright (c) 2025 Digvijay Chauhan
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

using System;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Rapp.Gen
{
/// <summary>
/// Minimal test generator to verify analyzer loading.
/// </summary>
[Generator]
public class TestGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // No-op
    }

    public void Execute(GeneratorExecutionContext context)
    {
        context.AddSource("TestGenerated.g.cs", "// Test generated code");
    }
}

[Generator]
public class RappGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Simple test: Always add a source file to verify generator is running
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("TestGenerator.g.cs", "// Test: Generator is working!"));

        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is ClassDeclarationSyntax,
                transform: (ctx, _) => GetClassToGenerate(ctx))
            .Where(m => m is not null);

        context.RegisterSourceOutput(provider, Execute);
    }

    private static INamedTypeSymbol? GetClassToGenerate(GeneratorSyntaxContext context)
    {
        var declaration = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(declaration) as INamedTypeSymbol;
        if (symbol is not null)
        {
            var attributes = symbol.GetAttributes();
            foreach (var attr in attributes)
            {
                var attrName = attr.AttributeClass?.Name;
                var attrDisplay = attr.AttributeClass?.ToDisplayString();
                if (attr.AttributeClass?.Name == "RappCacheAttribute" || 
                    attr.AttributeClass?.Name == "RappCache" ||
                    attr.AttributeClass?.ToDisplayString() == "Rapp.RappCacheAttribute" ||
                    attr.AttributeClass?.ToDisplayString() == "Rapp.RappCache")
                {
                    return symbol;
                }
            }
        }
        return null;
    }

    private static void Execute(SourceProductionContext context, INamedTypeSymbol? symbol)
    {
        if (symbol is null)
        {
            var testCode = "// No symbol provided";
            context.AddSource("RappGenerator.NoSymbol.g.cs", SourceText.From(testCode, Encoding.UTF8));
            return;
        }

        var className = symbol.Name;
        var fullType = symbol.ToDisplayString();
        var serializerName = $"{className}RappSerializer";
        var hash = ComputeSchemaHash(symbol);

        var code = $@"
// <auto-generated/>
using Rapp;
using Microsoft.Extensions.Caching.Hybrid;
using Microsoft.Extensions.DependencyInjection;
using System.ComponentModel;

namespace Rapp
{{
    [EditorBrowsable(EditorBrowsableState.Never)]
    public sealed class {serializerName} : RappBaseSerializer<{fullType}>
    {{
        protected override ulong SchemaHash => {hash}UL;
        protected override string TypeName => ""{className}"";

        public new void Serialize({fullType} value, System.Buffers.IBufferWriter<byte> target)
        {{
            base.Serialize(value, target);
        }}

        public new {fullType} Deserialize(System.Buffers.ReadOnlySequence<byte> source)
        {{
            var result = base.Deserialize(source);
            return result;
        }}
    }}
}}

namespace Rapp
{{
    public static partial class Rapp{className}Extensions
    {{
#pragma warning disable EXTEXP0018 // IHybridCacheBuilder is experimental
        public static Microsoft.Extensions.Caching.Hybrid.IHybridCacheBuilder UseRappFor{className}(this Microsoft.Extensions.Caching.Hybrid.IHybridCacheBuilder builder)
        {{
            return builder.AddSerializer<{fullType}, Rapp.{serializerName}>();
        }}
#pragma warning restore EXTEXP0018
    }}
}}
";

        context.AddSource($"{className}.Rapp.g.cs", SourceText.From(code, Encoding.UTF8));
    }

    /// <summary>
    /// Computes a cryptographic hash of the type's schema for schema validation.
    /// </summary>
    /// <param name="symbol">The type symbol to compute the hash for.</param>
    /// <returns>A string representation of the hash as a hexadecimal ulong value.</returns>
    /// <remarks>
    /// This hash is computed from the type's structural elements including:
    /// - Type name and namespace
    /// - All public properties and their types
    /// - All public fields and their types
    /// - Generic type parameters (if any)
    /// 
    /// The hash ensures that any changes to the type structure will result in
    /// a different hash, preventing deserialization of incompatible data.
    /// </remarks>
    private static string ComputeSchemaHash(INamedTypeSymbol symbol)
    {
        using var sha256 = SHA256.Create();
        
        var schemaData = new StringBuilder();
        
        // Include type identity
        schemaData.AppendLine($"Type:{symbol.ToDisplayString()}");
        schemaData.AppendLine($"Name:{symbol.Name}");
        schemaData.AppendLine($"Namespace:{symbol.ContainingNamespace?.ToDisplayString() ?? "global"}");
        
        // Include generic type parameters if any
        if (symbol.IsGenericType)
        {
            schemaData.AppendLine("TypeParameters:");
            foreach (var typeParam in symbol.TypeParameters)
            {
                schemaData.AppendLine($"  {typeParam.Name}:{typeParam.ToDisplayString()}");
            }
        }
        
        // Include all public properties
        var properties = symbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public)
            .OrderBy(p => p.Name);
            
        schemaData.AppendLine("Properties:");
        foreach (var prop in properties)
        {
            schemaData.AppendLine($"  {prop.Name}:{prop.Type.ToDisplayString()}");
        }
        
        // Include all public fields
        var fields = symbol.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => f.DeclaredAccessibility == Accessibility.Public && !f.IsImplicitlyDeclared)
            .OrderBy(f => f.Name);
            
        schemaData.AppendLine("Fields:");
        foreach (var field in fields)
        {
            schemaData.AppendLine($"  {field.Name}:{field.Type.ToDisplayString()}");
        }
        
        // Compute hash
        var data = Encoding.UTF8.GetBytes(schemaData.ToString());
        var hashBytes = sha256.ComputeHash(data);
        
        // Take first 8 bytes and convert to ulong (little-endian)
        var hashValue = BitConverter.ToUInt64(hashBytes, 0);
        
        return $"0x{hashValue:X16}";
    }
}
}
